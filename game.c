/******************************************************************************
*  @file       	game.c
*  @brief      	Main game code file
*  @author     	Ron
*  @created 	November 14, 2017
*  @modified   	November 17, 2017
*      
*  @par [explanation]
*		> 
******************************************************************************/
 
#include "neslib.h"

// Nametables for game screens
#include "title_nam.h"

// Palettes
const unsigned char palTitle[16] = { 0x0f,0x00,0x10,0x30,0x0f,0x01,0x21,0x31,0x0f,0x06,0x16,0x26,0x0f,0x09,0x19,0x29 };

// Music data is included as .s file generated by the text2data tool from music.ftm
extern const unsigned char music_music_data[];

// Sound effects enum
enum
{
	SFX_START = 0,
	SFX_ITEM,
	SFX_RESPAWN1,
	SFX_RESPAWN2
};

// Music enum
enum
{
	MUSIC_LEVEL = 0,
	MUSIC_GAME,
	MUSIC_CLEAR,
	MUSIC_GAME_OVER,
	MUSIC_WELL_DONE,
	MUSIC_LOSE
};

// Index of color of "press start" text in title palette, used for blinking animation
#define PRESS_START_PAL_INDEX 6

// Put all the subsequent global vars into zeropage
#pragma bss-name (push,"ZEROPAGE")
#pragma data-name(push,"ZEROPAGE")

// Set of general purpose global vars that are used everywhere in the program
// This makes code faster and shorter, although not very convenient and readable
static unsigned char i,j;
static unsigned char frameCounter;
// static unsigned char wait;

// Used in pal_fade_to
static unsigned char bright;

#pragma data-name(pop)
#pragma bss-name (pop)
// Following variables will go to the default RAM location (BSS)

// Smoothly fade current bright to the given value
// When to=0, stop music, turn display off, reset vram update and scroll
void pal_fade_to(unsigned to)
{
	if (!to) music_stop();

	while (bright != to)
	{
		delay(4);
		if (bright<to) 	++bright;
		else 			--bright;
		pal_bright(bright);
	}

	if (!bright)
	{
		ppu_off();
		set_vram_update(NULL);
		scroll(0,0);
	}
}

void titlePhase(void)
{
	// Start and target bright levels
	i = 0;
	j = 4;

	// Start faded out
	pal_bright(i);
	
	// Reset scroll
	scroll(0, 0);
	
	// Load title nametable
	vram_adr(NAMETABLE_A);
	vram_unrle(title_nam);
	// Set title palette
	pal_bg(palTitle);
	// Turn on background display
	ppu_on_bg();

	// Counter used for title screen fade-in
	frameCounter = 0;
	
	while (1)
	{
		ppu_wait_frame();
		
		// If start button is pressed, exit the title loop
		if (pad_trigger(0)&PAD_START)	break;
		
		// Update frame count
		frameCounter++;

		// Update title screen fade in
		// Note: Not using pal_fade_to here to allow polling start button simultaneously
		if (i < j)
		{
			// Fade in title screen
			if (!(frameCounter&7))
			{
				i++;
				pal_bright(i);
			}
		}
		// Blink "press start" text
		else
		{
			// Toggle text color between BG color (black) and actual color (blue)
			pal_col(PRESS_START_PAL_INDEX, (frameCounter&32) ? 0x0f : 0x22);
		}
	}
		
	// Set bright level to target level
	pal_bright(j);
	
	// Play start game sound
	sfx_play(SFX_START, 0);
	
	// Blink text faster, 8x
	for (i = 0; i < 16; ++i)
	{
		pal_col(PRESS_START_PAL_INDEX, (i%2) ? 0x0f : 0x22);
		delay(4);
	}

	// Fade out
	pal_fade_to(0);
}

void gamePhase(void)
{			
	// Game loop
	//	Initialize:
	// 		Setup vram update for blank tiles and HUD coins
	// 		Load level nametable, HUD nametable
	//		Read vram, remove map start and exit points from map data
	//		Write back edited map to vram
	//		Spawn player sprite on map start point
	// 		Fade in game screen
	//	Loop:
	//		Detect input
	//		If arrows, move player in arrow direction
	//			Detect collisions with walls
	//			Make player movement tile-based (one press to automatically move one tile)
	//			When player reaches exit point, set success flag, exit game loop
	//		If buttons, play music/sfx
	//	Fade out game screen
}

void resultPhase(void)
{
	// Result loop
	//	Load result according to success flag
	//	Fade in result screen
	//	On Start button press:
	//		Fade out result screen
	//		Exit result loop (return to main infinite loop -> title loop)
	while (1)
	{
		// If start button is pressed, exit the result loop
		if (pad_trigger(0)&PAD_START)	break;
	}
}

// This is where the program starts
void main(void)
{
	while (1) // Infinite loop
	{
		titlePhase();
		
		gamePhase();

		resultPhase();
	}
}
